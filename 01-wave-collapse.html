<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Decoherence Demo 1 â€“ Wavefunction Collapse</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #020617;
  }
  canvas {
    width: 100%;
    height: auto;
    display: block;
}

</style>
  <script type="importmap">  
        {  
            "imports": {  
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js"  
            }  
        }  
    </script>  

</head>
<body>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020617);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.set(0, 0, 4);

const geometry = new THREE.PlaneGeometry(6, 3, 400, 200);

const uniforms = {
  uTime: { value: 0 },
  uCollapse: { value: 0 },
  uColor1: { value: new THREE.Color(0x00e5ff) },
  uColor2: { value: new THREE.Color(0x0099ff) }
};

const material = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    precision highp float;
    varying vec2 vUv;
    uniform float uTime;
    uniform float uCollapse;
    uniform vec3 uColor1;
    uniform vec3 uColor2;

    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
    }

    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) +
             (c - a) * u.y * (1.0 - u.x) +
             (d - b) * u.x * u.y;
    }

    void main() {
      vec2 uv = vUv;
      uv.x *= 3.0;

      float t = uTime * 0.5;

      float wave1 = sin(uv.x * 6.0 - t * 2.0);
      float wave2 = sin(uv.x * 7.5 + t * 1.8);

      float interference = wave1 + wave2;
      float height = interference * 0.25;

      float decoNoise = noise(uv * 5.0 + t);
      float phaseJitter = mix(0.0, decoNoise * 4.0, uCollapse);
      float ampNoise = mix(0.0, (decoNoise - 0.5) * 2.0, uCollapse);

      float wave3 = sin(uv.x * 9.0 + t * 2.6 + phaseJitter);
      float decoPattern = interference + ampNoise + wave3 * uCollapse;

      float y = uv.y * 2.0 - 1.0;
      float band = smoothstep(0.08, 0.0, abs(y - height));
      float bandDeco = smoothstep(0.2, 0.0, abs(y - decoPattern * 0.25));

      float mask = mix(band, bandDeco, uCollapse);

      vec3 base = mix(uColor2, uColor1, 0.5 + 0.5 * decoPattern);
      vec3 col = base * mask;

      float bg = 0.15 + 0.25 * (1.0 - abs(y));
      col += vec3(0.02, 0.06, 0.1) * bg;

      float bright = pow(mask, 3.0);
      col += vec3(0.2, 0.7, 1.0) * bright * 0.7;

      gl_FragColor = vec4(col, 1.0);
    }
  `
});

const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.2,
  0.4,
  0.9
);
composer.addPass(bloomPass);

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h);
  composer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener("resize", resize);
resize();

let start = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const t = (performance.now() - start) / 1000;

  uniforms.uTime.value = t;
  uniforms.uCollapse.value = Math.min(1.0, t / 12.0);

  composer.render();
}
animate();
</script>
</body>
</html>
