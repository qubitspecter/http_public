<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Decoherence Demo 2 â€“ Particle Cloud</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #020617;
  }
  canvas { display: block; }
</style>
  <script type="importmap">  
        {  
            "imports": {  
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js"  
            }  
        }  
    </script>  

</head>
<body>
<canvas id="c"></canvas>
<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020617, 0.25);
scene.background = new THREE.Color(0x020617);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 50);
camera.position.set(0, 0, 6);

const COUNT = 5000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const phases = new Float32Array(COUNT);

for (let i = 0; i < COUNT; i++) {
  const r = Math.random() * 1.8;
  const theta = Math.random() * Math.PI * 2.0;
  const phi = Math.acos(2.0 * Math.random() - 1.0);
  const x = r * Math.sin(phi) * Math.cos(theta);
  const y = r * Math.sin(phi) * Math.sin(theta);
  const z = r * Math.cos(phi);
  positions[i * 3 + 0] = x;
  positions[i * 3 + 1] = y;
  positions[i * 3 + 2] = z;
  phases[i] = Math.random() * Math.PI * 2.0;
}
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

const uniforms = {
  uTime: { value: 0 },
  uCollapse: { value: 0 },
  uColor: { value: new THREE.Color(0x00e5ff) },
  uColor2: { value: new THREE.Color(0x00b4ff) }
};

const material = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    attribute float phase;
    uniform float uTime;
    uniform float uCollapse;
    varying float vStrength;

    void main() {
      vec3 p = position;

      // coherent motion: orbital / breathing
      float t = uTime * 0.4;
      float radial = length(p);
      float wave = sin(radial * 3.5 - t * 4.0 + phase);

      // quantum-like correlated motion
      vec3 coherentOffset = normalize(p + 0.001) * wave * 0.15;

      // decoherent chaotic jitter
      float chaos = sin(phase * 17.0 + uTime * 12.0) * sin(phase * 29.0 + uTime * 7.0);
      vec3 decoOffset = vec3(
        chaos * 0.6,
        sin(phase * 11.0 + uTime * 9.0) * 0.6,
        sin(phase * 23.0 + uTime * 5.0) * 0.6
      );

      vec3 finalPos = p + mix(coherentOffset, decoOffset, uCollapse);

      float strength = smoothstep(1.8, 0.0, length(finalPos));
      vStrength = strength;

     vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
gl_Position = projectionMatrix * mvPosition;

gl_PointSize = mix(1.5, 4.0, strength) * (1.0 + uCollapse * 0.8);
gl_PointSize *= (300.0 / -mvPosition.z);

    }
  `,
  fragmentShader: `
    precision highp float;
    uniform vec3 uColor;
    uniform vec3 uColor2;
    uniform float uCollapse;
    varying float vStrength;

    void main() {
      vec2 uv = gl_PointCoord * 2.0 - 1.0;
      float r = length(uv);
      float alpha = smoothstep(1.0, 0.0, r);
      float core = smoothstep(0.3, 0.0, r);

      vec3 col = mix(uColor, uColor2, vStrength);
      col += vec3(0.2, 0.9, 1.0) * core * 0.4;

      float decoGrain = fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453);
      float decoMask = mix(1.0, decoGrain * 1.4, uCollapse);

      gl_FragColor = vec4(col, alpha * vStrength * decoMask);
      if (gl_FragColor.a < 0.02) discard;
    }
  `,
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending
});

const points = new THREE.Points(geometry, material);
scene.add(points);

// Postprocessing
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.6, 0.4, 0.95
);
composer.addPass(bloom);

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h);
  composer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

let start = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const t = (performance.now() - start) / 1000;

  uniforms.uTime.value = t;
  uniforms.uCollapse.value = Math.min(1.0, t / 10.0); // 10s to decohere

  // slow camera orbit
  camera.position.x = Math.sin(t * 0.08) * 2.0;
  camera.position.z = 6.0 + Math.cos(t * 0.08) * 1.0;
  camera.lookAt(0, 0, 0);

  composer.render();
}
animate();
</script>
</body>
</html>
