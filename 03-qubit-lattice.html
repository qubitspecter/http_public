<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Decoherence Demo 3 â€“ Qubit Lattice</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #020617;
  }
  canvas { display: block; }
</style>
<script type="importmap">  
        {  
            "imports": {  
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js"  
            }  
        }  
    </script>  
</head>
<body>
<canvas id="c"></canvas>
<script type="module">
import * as THREE from 'three';  
console.log('Three.js loaded:', THREE);  
import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020617);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 4, 10);
camera.lookAt(0, 0, 0);

const GRID = 18;
const spacing = 0.8;
const count = GRID * GRID;
const geometry = new THREE.InstancedBufferGeometry().copy(new THREE.SphereGeometry(0.12, 24, 24));

const offsets = new Float32Array(count * 3);
const phases = new Float32Array(count);

let i = 0;
for (let x = 0; x < GRID; x++) {
  for (let y = 0; y < GRID; y++) {
    const idx = i * 3;
    offsets[idx + 0] = (x - GRID / 2) * spacing;
    offsets[idx + 1] = (y - GRID / 2) * spacing;
    offsets[idx + 2] = 0.0;
    phases[i] = Math.random() * Math.PI * 2.0;
    i++;
  }
}
geometry.setAttribute('instanceOffset', new THREE.InstancedBufferAttribute(offsets, 3));
geometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(phases, 1));

const uniforms = {
  uTime: { value: 0 },
  uCollapse: { value: 0 },
  uColor: { value: new THREE.Color(0x00e5ff) }
};

const material = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    attribute vec3 instanceOffset;
    attribute float instancePhase;
    uniform float uTime;
    uniform float uCollapse;
    varying float vIntensity;

    void main() {
      float t = uTime * 3.0;
      float basePhase = t + instancePhase;

      // coherent global oscillation
      float coherent = sin(t);

      // decoherent local phase jitter
      float deco = sin(instancePhase * 13.0 + uTime * 9.0);

      float phase = mix(coherent, deco, uCollapse);
      float amp = mix(1.0, 0.4 + 0.6 * abs(deco), uCollapse);

      float pulse = 0.5 + 0.5 * sin(basePhase) * amp;

      vec3 transformedPos = position * (0.6 + pulse * 0.7);
      transformedPos.y += pulse * 0.12;

      vec3 worldPos = instanceOffset + transformedPos;
      vIntensity = pulse;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPos, 1.0);
    }
  `,
  fragmentShader: `
    precision highp float;
    uniform vec3 uColor;
    uniform float uCollapse;
    varying float vIntensity;

    void main() {
      vec3 col = uColor;
      col *= 0.4 + 0.6 * vIntensity;
      col += vec3(0.3, 0.9, 1.0) * pow(vIntensity, 3.0) * 0.7;
      float decoGrain = fract(sin(vIntensity * 43758.5453) * 12.345);
      col += decoGrain * uCollapse * 0.08;
      gl_FragColor = vec4(col, 1.0);
    }
  `,
  transparent: false
});

const mesh = new THREE.Mesh(geometry, material);
// mesh.instanceMatrix.needsUpdate = true;
scene.add(mesh);

// entanglement lines (simple grid lines)
const lineGeo = new THREE.BufferGeometry();
const linePositions = [];
for (let x = 0; x < GRID; x++) {
  const xPos = (x - GRID / 2) * spacing;
  linePositions.push(xPos, (0 - GRID / 2) * spacing, 0);
  linePositions.push(xPos, (GRID - 1 - GRID / 2) * spacing, 0);
}
for (let y = 0; y < GRID; y++) {
  const yPos = (y - GRID / 2) * spacing;
  linePositions.push((0 - GRID / 2) * spacing, yPos, 0);
  linePositions.push((GRID - 1 - GRID / 2) * spacing, yPos, 0);
}
lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));

const lineMat = new THREE.LineBasicMaterial({
  color: 0x00aaff,
  transparent: true,
  opacity: 0.3
});
const gridLines = new THREE.LineSegments(lineGeo, lineMat);
scene.add(gridLines);

// Postprocessing
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.4, 0.4, 0.85
);
composer.addPass(bloom);

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h);
  composer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

let start = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const t = (performance.now() - start) / 1000;
  uniforms.uTime.value = t;
  uniforms.uCollapse.value = Math.min(1.0, t / 12.0);

  // subtle camera motion
  camera.position.x = Math.sin(t * 0.1) * 3.0;
  camera.position.z = 10 + Math.cos(t * 0.1) * 2.0;
  camera.lookAt(0, 0, 0);

  composer.render();
}
animate();
</script>
</body>
</html>
